=== Copying Files
[role="byline"]
by Stefan Karlsson

==== Problem

You need to copy a file on your local filesystem.((("I/O (input/output) streams", "copying files")))(((files, copying)))((("Clojure", "clojure.java.io/copy")))

==== Solution

Invoke +clojure.java.io/copy+, passing it the source and destination files:

[source,clojure]
----
(clojure.java.io/copy
  (clojure.java.io/file "./file-to-copy.txt")
  (clojure.java.io/file "./my-new-copy.txt"))
;; -> nil
----

If the input file is not found,(((exceptions/errors, java.io.FileNotFoundException))) a +java.io.FileNotFoundException+ will be thrown:
[source,clojure]
----
(clojure.java.io/copy
  (clojure.java.io/file "./file-do-not-exist.txt")
  (clojure.java.io/file "./my-new-copy.txt"))
;; -> java.io.FileNotFoundException
----

The input argument to +copy+ doesn't have to be a file; it can be an
+InputStream+, a +Reader+, a byte array, or a string. This makes it
easier to copy the data you are working with directly to the output
file:

[source,clojure]
----
(clojure.java.io/copy "some text" (clojure.java.io/file "./str-test.txt"))
;; -> nil
----

If required, an encoding can be specified by the +:encoding+ option:

[source,clojure]
----
(clojure.java.io/copy "some text"
                      (clojure.java.io/file "./str-test.txt")
                      :encoding "UTF-8")
----

==== Discussion

Note that if the file already exists, it will be overwritten. If that(((safe-copy function)))(((overwriting)))(((functions, safe-copy)))
is not what you want, you can put together a "safe" copy function that
will catch any exceptions and optionally overwrite:

[source,clojure]
----
(defn safe-copy [source-path destination-path & opts]
  (let [source (clojure.java.io/file source-path)
        destination (clojure.java.io/file destination-path)
        options (merge {:overwrite false} (apply hash-map opts))] ; <1>
    (if (and (.exists source)	   	  	 	  	  ; <2>
             (or (:overwrite options) 
                 (= false (.exists destination))))
      (try
        (nil? (clojure.java.io/copy source destination))	  ; <3>
        (catch Exception e (str "exception: " (.getMessage e))))
      false)))

(safe-copy "./file-to-copy.txt" "./my-new-copy.txt")
;; -> true
(safe-copy "./file-to-copy.txt" "./my-new-copy.txt")
;; -> false
(safe-copy "./file-to-copy.txt" "./my-new-copy.txt" :overwrite true)
;; -> true
----
The +safe-copy+ function takes the source and destination file paths to copy from and to. It also takes a number of key/value pairs as options. 

<1> These options are then merged with the default values. In this
    example, there is only one option, +:overwrite+, but with this
    structure for optional arguments, you can easily add your own (such
    as +:encoding+ if needed).
<2> After the options have been processed, the function checks whether the
    destination file exists, and if so, if it should be overwritten. If
    all is OK, it will then perform the +copy+ inside a +try-catch+
    body.
<3> Note the test for +nil?+ when the file is copied.
    If you add this, you will always get a Boolean value from the
    function. This makes the function more convenient to use, since
    you can then conditionally check whether the operation succeed or not.

You can also use +clojure.java.io/copy+ with a +java.io.Reader+ and a +java.io.Writer+, as well as with streams:

[source,clojure]
----
(with-open [reader (clojure.java.io/reader "file-to-copy.txt")
            writer (clojure.java.io/writer "my-new-copy.txt")]
  (clojure.java.io/copy reader writer))
----

The same efficiency considerations that apply to reading and writing to a file in regard to selecting input and output sources from +File+, +Reader+, +Writer+, or streams should be applied to +copy+. See <<sec_local-io_read_write_files>>, for more information.

By default, a buffer size of 1,024 bytes is used when calling +copy+. That is the amount of data that will be read from the source and written to the destination in one pass. This is done until the complete source has been copied. The buffer size used can be changed with the +:buffer-size+ option. Keeping this number low would cause more file access operations but would keep less data in memory. On the other hand, increasing the buffer size will lower the number of file accesses but will require more data to be loaded into memory.

==== See Also

* ++clojure.java.io++'s http://bit.ly/clj-java-io-api[API documentation]
