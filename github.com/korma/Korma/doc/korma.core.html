<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>korma.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Korma 0.3.0-RC6 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="korma.config.html"><span>korma.config</span></a></li><li class="current"><a href="korma.core.html"><span>korma.core</span></a></li><li><a href="korma.db.html"><span>korma.db</span></a></li><li><a href="korma.mysql.html"><span>korma.mysql</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="korma.core.html#var-aggregate"><span>aggregate</span></a></li><li><a href="korma.core.html#var-as-sql"><span>as-sql</span></a></li><li><a href="korma.core.html#var-belongs-to"><span>belongs-to</span></a></li><li><a href="korma.core.html#var-create-entity"><span>create-entity</span></a></li><li><a href="korma.core.html#var-database"><span>database</span></a></li><li><a href="korma.core.html#var-defentity"><span>defentity</span></a></li><li><a href="korma.core.html#var-delete"><span>delete</span></a></li><li><a href="korma.core.html#var-delete*"><span>delete*</span></a></li><li><a href="korma.core.html#var-dry-run"><span>dry-run</span></a></li><li><a href="korma.core.html#var-entity-fields"><span>entity-fields</span></a></li><li><a href="korma.core.html#var-exec"><span>exec</span></a></li><li><a href="korma.core.html#var-exec-raw"><span>exec-raw</span></a></li><li><a href="korma.core.html#var-fields"><span>fields</span></a></li><li><a href="korma.core.html#var-from"><span>from</span></a></li><li><a href="korma.core.html#var-group"><span>group</span></a></li><li><a href="korma.core.html#var-has-many"><span>has-many</span></a></li><li><a href="korma.core.html#var-has-one"><span>has-one</span></a></li><li><a href="korma.core.html#var-having"><span>having</span></a></li><li><a href="korma.core.html#var-having*"><span>having*</span></a></li><li><a href="korma.core.html#var-insert"><span>insert</span></a></li><li><a href="korma.core.html#var-insert*"><span>insert*</span></a></li><li><a href="korma.core.html#var-intersect"><span>intersect</span></a></li><li><a href="korma.core.html#var-intersect*"><span>intersect*</span></a></li><li><a href="korma.core.html#var-join"><span>join</span></a></li><li><a href="korma.core.html#var-limit"><span>limit</span></a></li><li><a href="korma.core.html#var-many-to-many"><span>many-to-many</span></a></li><li><a href="korma.core.html#var-modifier"><span>modifier</span></a></li><li><a href="korma.core.html#var-offset"><span>offset</span></a></li><li><a href="korma.core.html#var-order"><span>order</span></a></li><li><a href="korma.core.html#var-pk"><span>pk</span></a></li><li><a href="korma.core.html#var-post-query"><span>post-query</span></a></li><li><a href="korma.core.html#var-prepare"><span>prepare</span></a></li><li><a href="korma.core.html#var-queries"><span>queries</span></a></li><li><a href="korma.core.html#var-query-only"><span>query-only</span></a></li><li><a href="korma.core.html#var-raw"><span>raw</span></a></li><li><a href="korma.core.html#var-select"><span>select</span></a></li><li><a href="korma.core.html#var-select*"><span>select*</span></a></li><li><a href="korma.core.html#var-set-fields"><span>set-fields</span></a></li><li><a href="korma.core.html#var-sql-only"><span>sql-only</span></a></li><li><a href="korma.core.html#var-sqlfn"><span>sqlfn</span></a></li><li><a href="korma.core.html#var-sqlfn*"><span>sqlfn*</span></a></li><li><a href="korma.core.html#var-subselect"><span>subselect</span></a></li><li><a href="korma.core.html#var-table"><span>table</span></a></li><li><a href="korma.core.html#var-transform"><span>transform</span></a></li><li><a href="korma.core.html#var-union"><span>union</span></a></li><li><a href="korma.core.html#var-union*"><span>union*</span></a></li><li><a href="korma.core.html#var-union-all"><span>union-all</span></a></li><li><a href="korma.core.html#var-union-all*"><span>union-all*</span></a></li><li><a href="korma.core.html#var-update"><span>update</span></a></li><li><a href="korma.core.html#var-update*"><span>update*</span></a></li><li><a href="korma.core.html#var-values"><span>values</span></a></li><li><a href="korma.core.html#var-where"><span>where</span></a></li><li><a href="korma.core.html#var-where*"><span>where*</span></a></li><li><a href="korma.core.html#var-with"><span>with</span></a></li><li><a href="korma.core.html#var-with-batch"><span>with-batch</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>korma.core documentation</h2><pre class="doc">Core querying and entity functions
</pre><div class="public" id="var-aggregate"><h3>aggregate</h3><h4 class="macro">macro</h4><div class="usage"><code>(aggregate query agg alias &amp; [group-by])</code></div><pre class="doc">Use a SQL aggregator function, aliasing the results, and optionally grouping by
a field:

(select users 
  (aggregate (count :*) :cnt :status))

Aggregates available: count, sum, avg, min, max, first, last</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L334">Source</a></div></div><div class="public" id="var-as-sql"><h3>as-sql</h3><div class="usage"><code>(as-sql query)</code></div><pre class="doc">Force a query to return a string of SQL when (exec) is called.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L422">Source</a></div></div><div class="public" id="var-belongs-to"><h3>belongs-to</h3><h4 class="macro">macro</h4><div class="usage"><code>(belongs-to ent sub-ent &amp; [opts])</code></div><pre class="doc">Add a belongs-to relationship for the given entity. It is assumed that the foreign key
is on the current entity with the format sub-ent-table_id: email.user_id = user.id.
Can optionally pass a map with a :fk key to explicitly set the foreign key.

(belongs-to users email {:fk :emailID})</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L574">Source</a></div></div><div class="public" id="var-create-entity"><h3>create-entity</h3><div class="usage"><code>(create-entity table)</code></div><pre class="doc">Create an entity representing a table in a database.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L497">Source</a></div></div><div class="public" id="var-database"><h3>database</h3><div class="usage"><code>(database ent db)</code></div><pre class="doc">Set the database connection to be used for this entity.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L632">Source</a></div></div><div class="public" id="var-defentity"><h3>defentity</h3><h4 class="macro">macro</h4><div class="usage"><code>(defentity ent &amp; body)</code></div><pre class="doc">Define an entity representing a table in the database, applying any modifications in
the body.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L647">Source</a></div></div><div class="public" id="var-delete"><h3>delete</h3><h4 class="macro">macro</h4><div class="usage"><code>(delete ent &amp; body)</code></div><pre class="doc">Creates a delete query, applies any modifying functions in the body and then
executes it. `ent` is either a string or an entity created by defentity.

ex: (delete user 
      (where {:id 7}))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L131">Source</a></div></div><div class="public" id="var-delete*"><h3>delete*</h3><div class="usage"><code>(delete* ent)</code></div><pre class="doc">Create an empty delete query. Ent can either be an entity defined by defentity,
or a string of the table name</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L62">Source</a></div></div><div class="public" id="var-dry-run"><h3>dry-run</h3><h4 class="macro">macro</h4><div class="usage"><code>(dry-run &amp; body)</code></div><pre class="doc">Wrap around a set of queries to print to the console all SQL that would 
be run and return dummy values instead of executing them.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L409">Source</a></div></div><div class="public" id="var-entity-fields"><h3>entity-fields</h3><div class="usage"><code>(entity-fields ent &amp; fields)</code></div><pre class="doc">Set the fields to be retrieved by default in select queries for the
entity.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L606">Source</a></div></div><div class="public" id="var-exec"><h3>exec</h3><div class="usage"><code>(exec query)</code></div><pre class="doc">Execute a query map and return the results.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L459">Source</a></div></div><div class="public" id="var-exec-raw"><h3>exec-raw</h3><div class="usage"><code>(exec-raw conn? &amp; [sql with-results?])</code></div><pre class="doc">Execute a raw SQL string, supplying whether results should be returned. `sql` can either be
a string or a vector of the sql string and its params. You can also optionally
provide the connection to execute against as the first parameter.

(exec-raw [&quot;SELECT * FROM users WHERE age &gt; ?&quot; [5]] :results)</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L479">Source</a></div></div><div class="public" id="var-fields"><h3>fields</h3><div class="usage"><code>(fields query &amp; vs)</code></div><pre class="doc">Set the fields to be selected in a query. Fields can either be a keyword
or a vector of two keywords [field alias]:

(fields query :name [:firstname :first])</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L199">Source</a></div></div><div class="public" id="var-from"><h3>from</h3><div class="usage"><code>(from query table)</code></div><pre class="doc">Add tables to the from clause.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L215">Source</a></div></div><div class="public" id="var-group"><h3>group</h3><div class="usage"><code>(group query &amp; fields)</code></div><pre class="doc">Add a group-by clause to a select query
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L329">Source</a></div></div><div class="public" id="var-has-many"><h3>has-many</h3><h4 class="macro">macro</h4><div class="usage"><code>(has-many ent sub-ent &amp; [opts])</code></div><pre class="doc">Add a has-many relation for the given entity. It is assumed that the foreign key
is on the sub-entity with the format table_id: user.id = email.user_id
Can optionally pass a map with a :fk key to explicitly set the foreign key.

(has-many users email {:fk :emailID})</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L583">Source</a></div></div><div class="public" id="var-has-one"><h3>has-one</h3><h4 class="macro">macro</h4><div class="usage"><code>(has-one ent sub-ent &amp; [opts])</code></div><pre class="doc">Add a has-one relationship for the given entity. It is assumed that the foreign key
is on the sub-entity with the format table_id: user.id = address.user_id
Can optionally pass a map with a :fk key to explicitly set the foreign key.

(has-one users address {:fk :addressID})</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L565">Source</a></div></div><div class="public" id="var-having"><h3>having</h3><h4 class="macro">macro</h4><div class="usage"><code>(having query form)</code></div><pre class="doc">Add a having clause to the query, expressing the clause in clojure expressions
with keywords used to reference fields.
e.g. (having query (or (= :hits 1) (&gt; :hits 5)))

Available predicates: and, or, =, not=, &lt;, &gt;, &lt;=, &gt;=, in, like, not, between

Having can also take a map at any point and will create a clause that compares keys
to values. The value can be a vector with one of the above predicate functions
describing how the key is related to the value: (having query {:name [like &quot;chris&quot;})

Having only works if you have an aggregation, using it without one will cause an error.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L251">Source</a></div></div><div class="public" id="var-having*"><h3>having*</h3><div class="usage"><code>(having* query clause)</code></div><pre class="doc">Add a having clause to the query. Clause can be either a map or a string, and
will be AND'ed to the other clauses.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L245">Source</a></div></div><div class="public" id="var-insert"><h3>insert</h3><h4 class="macro">macro</h4><div class="usage"><code>(insert ent &amp; body)</code></div><pre class="doc">Creates an insert query, applies any modifying functions in the body and then
executes it. `ent` is either a string or an entity created by defentity. Inserts
return the last inserted id.

ex: (insert user 
      (values [{:name &quot;chris&quot;} {:name &quot;john&quot;}]))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L140">Source</a></div></div><div class="public" id="var-insert*"><h3>insert*</h3><div class="usage"><code>(insert* ent)</code></div><pre class="doc">Create an empty insert query. Ent can either be an entity defined by defentity,
or a string of the table name</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L70">Source</a></div></div><div class="public" id="var-intersect"><h3>intersect</h3><h4 class="macro">macro</h4><div class="usage"><code>(intersect &amp; body)</code></div><pre class="doc">Creates an intersect query, applies any modifying functions in the body and then
executes it.

ex: (intersect 
      (queries (subselect user
                 (where {:id 7}))
               (subselect user-backup
                 (where {:id 8})))
      (order :name))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L176">Source</a></div></div><div class="public" id="var-intersect*"><h3>intersect*</h3><div class="usage"><code>(intersect*)</code></div><pre class="doc">Create an empty intersect query.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L94">Source</a></div></div><div class="public" id="var-join"><h3>join</h3><h4 class="macro">macro</h4><div class="usage"><code>(join query ent)</code><code>(join query table clause)</code><code>(join query type table clause)</code></div><pre class="doc">Add a join clause to a select query, specifying the table name to
join and the predicate to join on. If the relationship uses a join
table then two clauses will be added. Otherwise, only one clause
will be added.

(join query addresses)
(join query addresses (= :addres.users_id :users.id))
(join query :right addresses (= :address.users_id :users.id))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L294">Source</a></div></div><div class="public" id="var-limit"><h3>limit</h3><div class="usage"><code>(limit query v)</code></div><pre class="doc">Add a limit clause to a select query.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L319">Source</a></div></div><div class="public" id="var-many-to-many"><h3>many-to-many</h3><h4 class="macro">macro</h4><div class="usage"><code>(many-to-many ent sub-ent join-table &amp; [opts])</code></div><pre class="doc">Add a many-to-many relation for the given entity.  It is assumed that a join
table is used to implement the relationship and that the foreign keys are in
the join table.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L599">Source</a></div></div><div class="public" id="var-modifier"><h3>modifier</h3><div class="usage"><code>(modifier query &amp; modifiers)</code></div><pre class="doc">Add a modifer to the beginning of a query:

(select orders
  (modifier &quot;DISTINCT&quot;))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L381">Source</a></div></div><div class="public" id="var-offset"><h3>offset</h3><div class="usage"><code>(offset query v)</code></div><pre class="doc">Add an offset clause to a select query.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L324">Source</a></div></div><div class="public" id="var-order"><h3>order</h3><div class="usage"><code>(order query field &amp; [dir])</code></div><pre class="doc">Add an ORDER BY clause to a select, union, union-all, or intersect query.
field should be a keyword of the field name, dir is ASC by default.

(order query :created :asc)</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L266">Source</a></div></div><div class="public" id="var-pk"><h3>pk</h3><div class="usage"><code>(pk ent pk)</code></div><pre class="doc">Set the primary key used for an entity. :id by default.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L627">Source</a></div></div><div class="public" id="var-post-query"><h3>post-query</h3><div class="usage"><code>(post-query query post)</code></div><pre class="doc">Add a function representing a query that should be executed for each result in a select.
This is done lazily over the result set.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L313">Source</a></div></div><div class="public" id="var-prepare"><h3>prepare</h3><div class="usage"><code>(prepare ent func)</code></div><pre class="doc">Add a function to be applied to records/values going into the database
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L642">Source</a></div></div><div class="public" id="var-queries"><h3>queries</h3><div class="usage"><code>(queries query &amp; queries)</code></div><pre class="doc">Adds a group of queries to a union, union-all or intersect
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L350">Source</a></div></div><div class="public" id="var-query-only"><h3>query-only</h3><h4 class="macro">macro</h4><div class="usage"><code>(query-only &amp; body)</code></div><pre class="doc">Wrap around a set of queries to force them to return their query objects.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L416">Source</a></div></div><div class="public" id="var-raw"><h3>raw</h3><div class="usage"><code>(raw s)</code></div><pre class="doc">Embed a raw string of SQL in a query. This is used when Korma doesn't
provide some specific functionality you're looking for:

(select users
  (fields (raw &quot;PERIOD(NOW(), NOW())&quot;)))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L389">Source</a></div></div><div class="public" id="var-select"><h3>select</h3><h4 class="macro">macro</h4><div class="usage"><code>(select ent &amp; body)</code></div><pre class="doc">Creates a select query, applies any modifying functions in the body and then
executes it. `ent` is either a string or an entity created by defentity.

ex: (select user 
      (fields :name :email)
      (where {:id 2}))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L111">Source</a></div></div><div class="public" id="var-select*"><h3>select*</h3><div class="usage"><code>(select* ent)</code></div><pre class="doc">Create an empty select query. Ent can either be an entity defined by defentity,
or a string of the table name</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L38">Source</a></div></div><div class="public" id="var-set-fields"><h3>set-fields</h3><div class="usage"><code>(set-fields query fields-map)</code></div><pre class="doc">Set the fields and values for an update query.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L210">Source</a></div></div><div class="public" id="var-sql-only"><h3>sql-only</h3><h4 class="macro">macro</h4><div class="usage"><code>(sql-only &amp; body)</code></div><pre class="doc">Wrap around a set of queries so that instead of executing, each will return a string of the SQL 
that would be used.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L402">Source</a></div></div><div class="public" id="var-sqlfn"><h3>sqlfn</h3><h4 class="macro">macro</h4><div class="usage"><code>(sqlfn func &amp; params)</code></div><pre class="doc">Call an arbitrary SQL function by providing func as a symbol or keyword
and its params</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L365">Source</a></div></div><div class="public" id="var-sqlfn*"><h3>sqlfn*</h3><div class="usage"><code>(sqlfn* fn-name &amp; params)</code></div><pre class="doc">Call an arbitrary SQL function by providing the name of the function
and its params</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L359">Source</a></div></div><div class="public" id="var-subselect"><h3>subselect</h3><h4 class="macro">macro</h4><div class="usage"><code>(subselect &amp; parts)</code></div><pre class="doc">Create a subselect clause to be used in queries. This works exactly like (select ...)
execept it will wrap the query in ( .. ) and make sure it can be used in any current
query:

(select users
  (where {:id [in (subselect users2 (fields :id))]}))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L371">Source</a></div></div><div class="public" id="var-table"><h3>table</h3><div class="usage"><code>(table ent t &amp; [alias])</code></div><pre class="doc">Set the name of the table and an optional alias to be used for the entity. 
By default the table is the name of entity's symbol.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L612">Source</a></div></div><div class="public" id="var-transform"><h3>transform</h3><div class="usage"><code>(transform ent func)</code></div><pre class="doc">Add a function to be applied to results coming from the database
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L637">Source</a></div></div><div class="public" id="var-union"><h3>union</h3><h4 class="macro">macro</h4><div class="usage"><code>(union &amp; body)</code></div><pre class="doc">Creates a union query, applies any modifying functions in the body and then
executes it.

ex: (union 
      (queries (subselect user
                 (where {:id 7}))
               (subselect user-backup
                 (where {:id 7})))
      (order :name))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L150">Source</a></div></div><div class="public" id="var-union*"><h3>union*</h3><div class="usage"><code>(union*)</code></div><pre class="doc">Create an empty union query.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L78">Source</a></div></div><div class="public" id="var-union-all"><h3>union-all</h3><h4 class="macro">macro</h4><div class="usage"><code>(union-all &amp; body)</code></div><pre class="doc">Creates a union-all query, applies any modifying functions in the body and then
executes it.

ex: (union-all 
      (queries (subselect user
                 (where {:id 7}))
               (subselect user-backup
                 (where {:id 7})))
      (order :name))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L163">Source</a></div></div><div class="public" id="var-union-all*"><h3>union-all*</h3><div class="usage"><code>(union-all*)</code></div><pre class="doc">Create an empty union-all query.
</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L86">Source</a></div></div><div class="public" id="var-update"><h3>update</h3><h4 class="macro">macro</h4><div class="usage"><code>(update ent &amp; body)</code></div><pre class="doc">Creates an update query, applies any modifying functions in the body and then
executes it. `ent` is either a string or an entity created by defentity.

ex: (update user 
      (set-fields {:name &quot;chris&quot;}) 
      (where {:id 4}))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L121">Source</a></div></div><div class="public" id="var-update*"><h3>update*</h3><div class="usage"><code>(update* ent)</code></div><pre class="doc">Create an empty update query. Ent can either be an entity defined by defentity,
or a string of the table name.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L53">Source</a></div></div><div class="public" id="var-values"><h3>values</h3><div class="usage"><code>(values query values)</code></div><pre class="doc">Add records to an insert clause. values can either be a vector of maps or a single
map.

(values query [{:name &quot;john&quot;} {:name &quot;ed&quot;}])</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L274">Source</a></div></div><div class="public" id="var-where"><h3>where</h3><h4 class="macro">macro</h4><div class="usage"><code>(where query form)</code></div><pre class="doc">Add a where clause to the query, expressing the clause in clojure expressions
with keywords used to reference fields.
e.g. (where query (or (= :hits 1) (&gt; :hits 5)))

Available predicates: and, or, =, not=, &lt;, &gt;, &lt;=, &gt;=, in, like, not, between

Where can also take a map at any point and will create a clause that compares keys
to values. The value can be a vector with one of the above predicate functions 
describing how the key is related to the value: (where query {:name [like &quot;chris&quot;})</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L232">Source</a></div></div><div class="public" id="var-where*"><h3>where*</h3><div class="usage"><code>(where* query clause)</code></div><pre class="doc">Add a where clause to the query. Clause can be either a map or a string, and
will be AND'ed to the other clauses.</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L226">Source</a></div></div><div class="public" id="var-with"><h3>with</h3><h4 class="macro">macro</h4><div class="usage"><code>(with query ent &amp; body)</code></div><pre class="doc">Add a related entity to the given select query. If the entity has a relationship
type of :belongs-to or :has-one, the requested fields will be returned directly in
the result map. If the entity is a :has-many, a second query will be executed lazily
and a key of the entity name will be assoc'd with a vector of the results.

(defentity email (entity-fields :email))
(defentity user (has-many email))
(select user
  (with email) =&gt; [{:name &quot;chris&quot; :email [{email: &quot;c@c.com&quot;}]} ...

With can also take a body that will further refine the relation:
(select user
   (with address
      (with state)
      (fields :address.city :state.state)
      (where {:address.zip x})))</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L717">Source</a></div></div><div class="public" id="var-with-batch"><h3>with-batch</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-batch query ent &amp; body)</code></div><pre class="doc">Add a related entity. This behaves like `with`, except that, for has-many relationships,
it runs a single query to get relations of all fetched rows. This is faster than regular `with`
but it doesn't support many of the additional options (order, limit, offset, group, having)</pre><div class="src-link"><a href="https://github.com/korma/Korma/blob/master/src/korma/core.clj#L786">Source</a></div></div></div></body></html>